from muko import *
from 风格控制终端 import *
from 格式化分镜文档 import *
from 本地大语言模型 import *

# 禁止超过800，会影响分镜生成的质量
单个视频字数 = 700

ai_model_write = "not local"

def 划清界限(说明):
    输出(f'============================={说明}=============================')


def 分段添加字幕(文案, 视频, 总时长):
    划清界限('分段添加字幕')
    纯文字 = 自动断句(文案).连文('')
    字幕时长 = 总时长 / len(纯文字)
    字幕列表 = 列表()
    序号 = 0
    for 子句 in 自动断句(文案):
        字幕 = (子句, 序号 * 字幕时长, (序号 + len(子句)) * 字幕时长)
        输出(子句)
        字幕列表.添加(字幕)
        序号 += len(子句)
    # 视频.添加字幕(字幕列表=字幕列表, 背景颜色=(255, 222, 0), 字幕颜色=(0, 0, 0), 字体大小=55)
    # 视频.添加字幕(字幕列表=字幕列表, 字幕颜色=(255, 222, 0), 描边颜色=(0, 0, 0), 描边宽度=1, 字体大小=35)
    视频.添加字幕(字幕列表=字幕列表, 字幕颜色=全局配置.字幕颜色, 字幕透明度=全局配置.字幕透明度,
                  字幕位置=全局配置.字幕位置, 字体大小=全局配置.字体大小,
                  背景尺寸比例=全局配置.背景尺寸比例, 字体=全局配置.字体,
                  背景颜色=全局配置.背景颜色, 背景透明度=全局配置.背景透明度, 描边颜色=全局配置.描边颜色,
                  描边宽度=全局配置.描边宽度, 描边透明度=全局配置.描边透明度,
                  间距=全局配置.字体间距)


def 拆分文案(文案文件夹):
    划清界限('拆分文案')
    文档 = 抓取TXT(全局配置.原文路径)
    累积文案 = ''
    新文档编号 = 0
    # 每次只做【单个视频字数】字
    for 行 in 自动断句(文档.读()):
        累积文案 += 行 + '\n'
        if len(累积文案) > 单个视频字数 - 20:
            新文档 = TXT(f'{文案文件夹}/{新文档编号}.txt')
            新文档编号 += 1
            新文档.写(累积文案)
            新文档.保存()
            累积文案 = ''
    if len(累积文案) > 0:
        新文档 = TXT(f'{文案文件夹}/{新文档编号}.txt')
        新文档.写(累积文案)
        新文档.保存()
    输出('成功！')


def 创建人物(文案文件夹, 人物文档):
    划清界限(f'创建{全局配置.类型}')
    人物列表 = 列表()
    for 文件名 in 遍历文件夹(f'{文案文件夹}'):
        当前文档 = 路径(文案文件夹, 文件名)
        全部文案 = 抓取TXT(当前文档).读()
        # 随机选择
        prompt = f'不带任何序号符号，只要名字，请提取出下面文字中的所有主要{全局配置.类型}名：{全部文案}'
        if ai_model_write == "local":
            # 全部人物 = get_message_from_qwenmax(prompt)
            全部人物 = get_message_from_ai(prompt)
        else:
            全部人物 = 写文(prompt)
        划清界限(f'全部{全局配置.类型}')
        输出(全部人物)
        划清界限(f'提取出每一个{全局配置.类型}')
        for 人物 in 自动断句(全部人物):
            # 太长的忽略
            if len(人物) > 4:
                continue
            输出(人物)
            人物列表.添加(人物)
    划清界限(f'保存{全局配置.类型}')
    新文档 = TXT(人物文档, 格式='文本')
    新文档.写(人物列表)
    新文档.保存()
    输出('成功！')


def 处理角色图片提示词(角色图片提示词):
    """
    过滤掉背景，方便后期添加其他背景
    :param 角色图片提示词:
    :return:
    """
    可用提示词列表 = 列表()
    for 词语 in 自动断句(角色图片提示词):
        if '背景' in 词语:
            continue
        可用提示词列表.添加(词语)
    return 可用提示词列表.连文('，')


def 创建角色图片提示词(人物文档, 角色图片提示词文档):
    划清界限('创建角色图片提示词')
    角色字典 = 字典()
    for 人物 in 抓取TXT(人物文档).读():
        输出(f'正在设计【{人物}】...')
        任务 = f'你是一名AI画图提示工程师，请根据{全局配置.类型}名设计一组图片关键词，每个关键词用逗号隔开，{全局配置.人物提示词风格}，下面是人物名：{人物}'
        if ai_model_write == "local":
            #角色图片提示词 = get_message_from_qwenmax(任务)
            角色图片提示词 = get_message_from_ai(任务)
        else:
            角色图片提示词 = 写文(任务)
        角色图片提示词 = 处理角色图片提示词(角色图片提示词)
        输出(角色图片提示词)
        角色字典.填写(人物, 角色图片提示词)
        输出('\n')
    # 定制固有角色
    角色字典.填写('我', '1男,solo,青年，短发,斯文,工服')
    新文档 = TXT(角色图片提示词文档, 格式='文本')
    新文档.写(角色字典)
    新文档.保存()
    输出(角色字典)
    输出('成功！')

def 创建段落列表文档自定义(原文,段落列表文档):

    当前文档文案 = 抓取TXT(原文).读()
    当前段落 = extract_sentences(当前文档文案)
    新文档 = TXT(段落列表文档, 格式='文本')
    新文档.写(当前段落)
    新文档.保存()
    输出('成功！')

def 创建段落列表文档(文案文件夹, 段落列表文档):
    划清界限('创建段落列表文档')
    当前段落 = ''
    段落列表 = 列表()
    for 文件名 in 遍历文件夹(f'{文案文件夹}', 序号='无'):
        当前文档 = 路径(文案文件夹, 文件名)
        当前文档文案 = 抓取TXT(当前文档).读()
        if len(当前文档文案) > 单个视频字数:
            输出('字数太多，容易造成AI幻觉降低分镜质量，请减少文字')
            return 当前文档文案
        else:
            for 行 in 自动断句(当前文档文案):
                当前段落 += 行
                if len(当前段落) > 5:
                    输出(当前段落)
                    段落列表.添加(当前段落)
                    当前段落 = ''
                    输出('\n')
                else:
                    # 换行
                    当前段落 += '\n'
            if len(当前段落) > 0:
                输出(当前段落)
                段落列表.添加(当前段落)
                # V1.4修改
    新文档 = TXT(段落列表文档, 格式='文本')
    新文档.写(段落列表)
    新文档.保存()
    输出('成功！')


def 创建分镜文档新版(段落列表文档, 分镜文档, 角色图片提示词文档, 重写次数=0):
    划清界限('创建分镜文档')
    # 分镜文档列表 = 列表()

    段落列表 = 抓取TXT(段落列表文档).读()
    # 内部固定的分镜模板
    分镜参考模板 = 抓取TXT(f'分镜模板/分镜模板.txt').读()
    角色图片提示词 = 抓取TXT(角色图片提示词文档).读()

    分镜结果 = ""

    任务指令 = f'将下列文案改写成一份分镜稿，不要改写、遗漏文案，文案是：“{段落列表}”，主题是{全局配置.主题}，将角色安排到合适的画面中：“{角色图片提示词}”，保持人物一致性，严格按照格式：{分镜参考模板}'
    if ai_model_write == "local":
        分镜结果  = get_message_from_ai(任务指令)
    else:
        分镜结果 = 写文(任务指令)
    输出(f'\n本次生成的分镜块：{分镜结果}')

    分镜结果 = 文本(分镜结果).替换('```json', '')
    分镜结果 = 文本(分镜结果).替换('```', '')


    新文档 = TXT(分镜文档, 格式='文本')
    新文档.写(分镜结果)
    新文档.保存()


def 创建分镜文档(段落列表文档, 分镜文档, 角色图片提示词文档, 重写次数=0):
    划清界限('创建分镜文档')
    # 分镜文档列表 = 列表()
    特效名字列表 = 列表()
    段落列表 = 抓取TXT(段落列表文档).读()
    # 内部固定的分镜模板
    分镜参考模板 = 抓取TXT(f'分镜模板/分镜模板.txt').读()
    角色图片提示词 = 抓取TXT(角色图片提示词文档).读()

    分镜结果 = ""

    dl_list = []
    for itor in 段落列表:
        dl_list.append(itor)
    # 指定每个分段的长度
    chunk_size = 1

    # 使用循环对列表进行分段处理
    for i in range(0, len(dl_list), chunk_size):
        # 使用切片获取每个分段
        chunk = dl_list[i:i + chunk_size]
        # 调用函数处理每个分段

        任务指令 = f'文案是：“{chunk}”，不要改动任何文案内容，只生成1个分镜块。其中：从“{角色图片提示词}”提取文案中的角色，角色可以是0个或者多个，集中放在一起。为文案设计1个画面，包括镜头景别，不要加特效，严格按照格式：{分镜参考模板}生成的角色和画面，不要输出格式要求之外的任何内容'
        if ai_model_write == "local":
            #分镜分块  = get_message_from_qwenmax(任务指令)
            分镜分块  = get_message_from_ai(任务指令)
        else:
            分镜分块 = 写文(任务指令)
        输出(f'\n本次生成的分镜块：{分镜分块}')
        分镜结果 += 分镜分块
    分镜结果 = 文本(分镜结果).替换('```json', '')
    分镜结果 = 文本(分镜结果).替换('```', '')
    分镜结果 = 文本(分镜结果).替换('\n][\n', ',\n')

    新文档 = TXT(分镜文档, 格式='文本')
    新文档.写(分镜结果)
    新文档.保存()
    try:
        尝试分镜列表 = 抓取TXT(分镜文档).读()
        尝试分镜列表.获取(0)
        输出('成功！')
    except:
        if 重写次数 < 3:
            输出(f'AI写文的结果不符合咱们的标准！重新生成！已重写次数：{重写次数}')
            创建分镜文档(段落列表文档, 分镜文档, 角色图片提示词文档, 重写次数=重写次数 + 1)
        else:
            输出(f'写文多次失败，请联系管理员：{重写次数}')
        return
    输出(f'\n\n分镜整理前：{尝试分镜列表}')
    分镜列表 = 过滤非法特效(尝试分镜列表, 特效名字列表)
    分镜列表 = 修正幻觉(分镜列表)
    输出(f'\n\n分镜整理后：{分镜列表}')
    新文档.写(分镜列表)
    新文档.保存()
def 过滤非法特效(分镜列表, 特效名字列表):
    """
    验证JSON数据中的“特效”字段是否存在于特效文件夹中，如果不存在则替换为空字符串。
    同时标准化键名。
    """
    for 分镜 in 分镜列表:
        特效名 = 分镜.获取('特效')
        if 特效名:
            # 检查特效文件是否存在于文件夹中
            if 特效名字列表.索引(特效名) < 0:
                print(f"修复AI写文的幻觉: 特效文件 '{特效名}' 不存在于文件夹中，将替换为空字符串。")
                分镜.填写('特效', '')
    return 分镜列表


def 修正幻觉(分镜列表):
    """
    标准化字典项的键名，确保其符合预期的格式，并按顺序重命名。
    """
    # 映射表，用于将可能的键名映射到标准键名
    英文幻觉 = 字典({
        'environment': '环境',
        'env': '环境',
        'scene': '环境',
        'character': '角色',
        'role': '角色',
        'char': '角色',
        'dialogue': '文案',
        'line': '文案',
        'effect': '特效',
        'fx': '特效',
        # 可以在此处添加更多映射
    })
    英文幻觉列表 = 英文幻觉.所有键()
    for 分镜 in 分镜列表:
        for 键 in 分镜.所有键():
            if 英文幻觉列表.索引(键) >= 0:
                中文键 = 英文幻觉.获取(键)
                值 = 分镜.获取(键)
                分镜.填写(中文键, 值)
                分镜.删除(键)
    return 分镜列表


# 全加版
def 匹配全部角色(段落):
    角色字典 = 抓取TXT(角色图片提示词文档).读()
    所有人物 = 角色字典.所有键()
    所有角色提示词 = ''
    for 人物 in 所有人物:
        if 人物 in 段落:
            角色提示词 = 角色字典.获取(人物)
            if 所有角色提示词:
                所有角色提示词 += ','
            所有角色提示词 += 角色提示词
    return 所有角色提示词


def 匹配最后出场角色(序号, 段落, 环境图片提示词):
    角色字典 = 抓取TXT(角色图片提示词文档).读()
    所有人物 = 角色字典.所有键()
    出现人物 = ''
    最后位置 = 0
    for 人物 in 所有人物:
        出现位置列表 = 文本(段落).出现位置(人物)
        if len(出现位置列表) > 0:
            当前人物最后位置 = 出现位置列表.获取(-1)
            if 当前人物最后位置 >= 最后位置:
                出现人物 = 人物
                最后位置 = 当前人物最后位置
    if 出现人物:
        # 开头之后，且有环境提示词的情况下，避免出现大量的同质化角色
        # if 出现人物 == '我' and 序号 > 2 and 环境图片提示词:
        #     要不要我 = 随机数(0, 100)
        #     # 一半以上概率不画“我”
        #     if 要不要我 > 45:
        #         return ''
        return 角色字典.获取(出现人物)
    else:
        # 没人的话返回主角
        # return 角色字典.获取('我')
        return ''


def 生成图片提示词(序号, 段落):
    任务 = f'从以下文案中提取出3个关键词，每个关键词用逗号隔开：{段落}'
    环境图片提示词 = 写文(任务)
    环境图片提示词 = 重点强调(环境图片提示词)
    输出(环境图片提示词)
    分镜字典 = 字典()
    分镜字典.填写('环境', 环境图片提示词)
    角色提示词 = 匹配最后出场角色(序号, 段落, 环境图片提示词)
    分镜字典.填写('角色', 角色提示词)
    分镜字典.填写('文案', 段落)
    return 分镜字典


def 重点强调(提示词):
    结果 = ''
    for 单词 in 自动断句(提示词):
        结果 += f'(({单词})),'
    return 结果


def 阅读分镜文档JSON(分镜文档):
    划清界限('阅读分镜文档')
    #分镜列表 = 抓取TXT(分镜文档).读()

    json_data = load_json(分镜文档)
    分镜列表 = 列表()
    for 分镜 in json_data:
        分镜列表.添加(分镜)
    return 分镜列表


def 阅读分镜文档(分镜文档):
    划清界限('阅读分镜文档')
    分镜列表 = 抓取TXT(分镜文档).读()

    for 分镜 in 分镜列表:
        输出(分镜)
    return 分镜列表


def 阅读角色图片提示词文档(角色图片提示词文档):
    划清界限('阅读角色图片提示词文档')
    角色字典 = 抓取TXT(角色图片提示词文档).读()
    for 角色 in 角色字典.所有键():
        输出(角色, '：', 角色字典.获取(角色))
    return 角色字典


class 特效师:

    def __init__(self, 素材路径):
        self.特效图层 = 抓取视频(素材路径)

    def 处理(self, 原图, 时间):
        特效图 = self.特效图层.读帧(时间)
        特效宽度 = 原图.宽 * 1.8
        特效图.缩放(宽度=特效宽度)
        左上角横坐标 = (原图.宽 - 特效图.宽) / 2
        左上角纵坐标 = (原图.高 - 特效图.高) / 2
        原图.粘贴(特效图, 左上角横坐标=左上角横坐标, 左上角纵坐标=左上角纵坐标, 混合模式='屏幕')
        return 原图


class 特效工厂:

    def __init__(self, 素材文件夹列表):
        self.素材文件夹列表 = 素材文件夹列表
        self.上一素材名 = None

    def 召唤特效师(self):
        素材文件夹 = 随机选择(self.素材文件夹列表)
        素材列表 = 遍历文件夹(素材文件夹)
        if self.上一素材名:
            # 避免重复
            素材列表.删除(self.上一素材名)
        素材名 = 随机选择(素材列表)
        素材路径 = 路径(素材文件夹, 素材名)
        self.上一素材名 = 素材名
        return 特效师(素材路径)

    def 指定特效师(self, 特效文件):
        素材文件夹 = self.素材文件夹列表.获取(0)
        素材路径 = 路径(素材文件夹, 特效文件)
        return 特效师(素材路径)


class 转场师:

    def __init__(self):
        self.转场序号 = 0
        # '动态模糊', '平滑聚焦',
        self.全部转场 = 列表('下移', '上移', '左移', '右移', '扩大', '缩小', '抖动')
        self.转场数量 = len(self.全部转场)

    def 挑选转场(self):
        转场 = self.全部转场.获取(self.转场序号)
        self.转场序号 += 1
        if self.转场序号 >= self.转场数量:
            self.转场序号 = 0
        return 转场


class 视频工厂:

    def __init__(self):
        self.特效工厂 = 特效工厂(全局配置.特效素材文件夹列表)
        self.转场师 = 转场师()

    def 调色(self, 图片):
        图片.设置模式('RGBA')

        for y in range(图片.高):
            for x in range(图片.宽):
                像素值 = 图片.获取像素(x, y)
                HSV = RGB转HSV(像素值)
                色相 = HSV.获取(0)
                饱和度 = HSV.获取(1)
                明度 = HSV.获取(2)
                # 开始调色
                # 色相 += 0.1
                # 降低饱和度
                饱和度 -= 0.05
                # 降低明度
                明度 -= 0.1
                RGB = HSV转RGB(列表(色相, 饱和度, 明度))
                图片.设置像素(x, y, RGB)
        # 创建一张蓝色图片作为蒙版滤镜
        # 滤镜 = 新建纯色图片(图片.宽, 图片.高, (0, 127, 255), 透明度=1)
        # 图片.粘贴(滤镜, 混合模式='溶解', 溶解度=0.2)
        return 图片

    def 暗蓝色(self, 图片, 时间):
        滤镜 = 新建纯色图片(图片.宽, 图片.高, (0, 127, 255), 透明度=1)
        图片.粘贴(滤镜, 混合模式='溶解', 溶解度=0.1)
        return 图片

    def 暗蓝滤镜(self, 视频):
        视频.逐帧(self.暗蓝色)
        return 视频

    def 处理背景音乐(self, 原背景音乐, 总视频时长):
        背景音乐列表 = 列表(原背景音乐, 序号='无')
        应剪时长 = 原背景音乐.时长
        while 应剪时长 < 总视频时长:
            背景音乐列表.添加(原背景音乐)
            应剪时长 += 原背景音乐.时长
        背景音乐 = 合并音频(背景音乐列表)
        # 背景音乐.调节音量(15)
        背景音乐.剪(结束时间=总视频时长)
        return 背景音乐

    def 坐标初始化(self, 视频尺寸, 背景尺寸):
        正常横坐标, 最左横坐标, 居中横坐标, 居中纵坐标 = 0, -50, (背景尺寸[0] - 视频尺寸[0]) / 2, (
                背景尺寸[1] - 视频尺寸[1]) / 2
        return 正常横坐标, 最左横坐标, 居中横坐标, 居中纵坐标

    def 随机转场(self, 视频, 背景尺寸):

        # 视频.缩放(宽度=1440)

        # 转场 = 随机选择(['下移', '上移', '左移', '右移', '扩大', '缩小', '动态模糊', '平滑聚焦', '抖动', '旋转', ])
        转场 = self.转场师.挑选转场()
        正常横坐标, 最左横坐标, 居中横坐标, 居中纵坐标 = self.坐标初始化(视频.尺寸, 背景尺寸)
        动画时长 = 视频.时长
        if 转场 == '下移':
            视频.平移(开始位置=(居中横坐标, 居中纵坐标 - 80), 结束位置=(居中横坐标, 居中纵坐标), 开始时间=0,
                      结束时间=动画时长)
        elif 转场 == '上移':
            视频.平移(开始位置=(居中横坐标, 居中纵坐标), 结束位置=(居中横坐标, 居中纵坐标 - 80), 开始时间=0,
                      结束时间=动画时长)
        elif 转场 == '左移':
            视频.平移(开始位置=(正常横坐标, 居中纵坐标), 结束位置=(最左横坐标, 居中纵坐标), 开始时间=0,
                      结束时间=动画时长)
        elif 转场 == '右移':
            视频.平移(开始位置=(最左横坐标, 居中纵坐标), 结束位置=(正常横坐标, 居中纵坐标), 开始时间=0,
                      结束时间=动画时长)
        elif 转场 == '扩大':
            视频.扩大动画()
        elif 转场 == '缩小':
            视频.缩放动画(初始比例=1.2, 结束比例=1)
        elif 转场 == '动态模糊':
            原始时长 = 视频.时长
            视频.动态模糊()
            # 输出('动态模糊前', 原始时长, '动态模糊后', 视频.时长)
            视频.剪(0, 原始时长)
            视频.平移(开始位置=(居中横坐标, 居中纵坐标 - 80), 结束位置=(居中横坐标, 居中纵坐标), 开始时间=0,
                      结束时间=动画时长)
        elif 转场 == '平滑聚焦':
            原始时长 = 视频.时长
            视频.平滑聚焦()
            视频.剪(0, 原始时长)
            视频.平移(开始位置=(居中横坐标, 居中纵坐标), 结束位置=(居中横坐标, 居中纵坐标 - 80), 开始时间=0,
                      结束时间=动画时长)
        elif 转场 == '抖动':
            视频.抖动(结束时间=0.4)
            视频.平移(开始位置=(居中横坐标, 居中纵坐标 - 100), 结束位置=(居中横坐标, 居中纵坐标), 开始时间=0,
                      结束时间=动画时长)

        return 视频

    def 随机特效(self, 视频):
        特效师 = self.特效工厂.召唤特效师()
        视频.逐帧(特效师.处理)
        return 视频

    def 指定特效(self, 视频, 特效文件):
        特效师 = self.特效工厂.指定特效师(特效文件)
        视频.逐帧(特效师.处理)
        return 视频


if __name__ == '__main__':
    print("hi 我是助手.py")
    #上传('高阶推文_竖屏短视频尺寸.mp4')
